
//3.7 Answer A: invalid assignment for x. We must write the code is: int*x=new int(100);
//3.9 Answer D: ce because *s=str means s[0]=str[0].
//3.11 Answer: B. Explanation:The pointer *arr always has size 4 byte, arr's size is because the array has 5 numbers, each one has 4 byte.
//3.12 Answer: D.
//3.13 The anser is A: *. * is used as dereferencing operator, used to read value stored at the pointed address.
//3.14 Answer: A. Explanation: *is to be grouped with the variables, not the data types.
//3.15 Answer: D. Explanation: A pointer can be in only 3 states a, band c.
//3.16 Answer: C. Explanation: dp is initialized int value of i.
//3.17 Answer: B. Explanation: Assigning to reference changes the object to which the reference is bound.
//3.18 Answer: D. Explanation: Array element cannot be address of auto variable.It can be address of static or extern variables.
//3.19 Answer: A. Explanation: Each time we are assigning 65 + i.In first iteration i = 0 and 65 is assigned.So it will print from A to J.
//3.20 Answer: A. Explanation: Pointer ptr points to string ‘fg’.So it prints fg.
//3.21 Answer: D. Explanation: A pointer can be initialized with null, zero and Address of an object of same type.
//3.22 Answer: D. Explanation: All of the above is not a correct way to pass a pointer to a function.
//3.23 Answer: B. 
//3.24 Answer: C. Explanation: Because when we call the operator new, the pointer will have a new memory in unlocated memory
//3.25 Answer: B. Explanation: Referencing a value through a pointer is called Indirection.
//3.26 Anwser: A.
//3.27 Answer: A.
//3.28 Answer: C. Explanation: There are three values that can be used to initialize a pointer; 0, NULL, or an address. Initializing a pointer to 0 and initializing that same pointer to NULL are identical.
//3.29 Answer: C. Explanation: &(address)
//3.30 Answer: C
//3.31 Answer: D. Explanation: because the const can't be changed.
//3.33 Answer: C. Explanation: *a is a[0]=4, then plus 10 equals to 15
//3.34 Answer: C. Explanation: because ra isn't a pointer so we can't let ra = a;
//3.35 The output is 2. Explanation: because ptr=a so the array a[0]=ptr[0], *ptr+1 means ptr[1]
//3.36 The output is 15. ptr=&a means we assign the address of a to ptr, so the value of a.
//3.37 The output is 222. Explanation: because we assign j=&i means pointer j has address memory of i, so the values.
//3.41 Answer: A. Explanation: int*ptr=new int(5);
//3.42 Answer: C